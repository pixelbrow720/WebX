import logging
import os
import requests
import re
import subprocess
import random
import string
import datetime
from urllib.parse import urlparse, urljoin, parse_qsl, urlencode

def check_status_codes(target):
    """Check for interesting HTTP status codes."""
    interesting_paths = [
        '/admin',
        '/login',
        '/wp-admin',
        '/administrator',
        '/phpmyadmin',
        '/config',
        '/.git',
        '/.env',
        '/backup',
        '/api',
        '/robots.txt',
        '/sitemap.xml'
    ]
    
    results = []
    
    for path in interesting_paths:
        url = urljoin(target, path)
        result = {
            'url': url,
            'interesting': False
        }
        
        try:
            response = requests.get(url, timeout=10, allow_redirects=False)
            result['status_code'] = response.status_code
            
            # Mark potentially interesting responses
            if response.status_code == 200:
                result['interesting'] = True
            elif response.status_code == 403:
                result['interesting'] = True
            elif 300 <= response.status_code < 400:
                result['interesting'] = True
                result['redirect_to'] = response.headers.get('Location', '')
        except requests.exceptions.Timeout:
            logging.warning(f"Timeout while checking {url}")
            result['error'] = 'Request timed out'
        except requests.exceptions.ConnectionError:
            logging.warning(f"Connection error while checking {url}")
            result['error'] = 'Connection error'
        except requests.exceptions.TooManyRedirects:
            logging.warning(f"Too many redirects while checking {url}")
            result['error'] = 'Too many redirects'
        except requests.exceptions.RequestException as e:
            logging.error(f"Error checking {url}: {str(e)}")
            result['error'] = str(e)
        
        results.append(result)
    
    return results

def check_security_headers(target):
    """Check for missing security headers."""
    security_headers = {
        'Strict-Transport-Security': 'HSTS not enabled',
        'Content-Security-Policy': 'CSP not enabled',
        'X-Content-Type-Options': 'X-Content-Type-Options missing',
        'X-Frame-Options': 'X-Frame-Options missing',
        'X-XSS-Protection': 'X-XSS-Protection missing'
    }
    
    results = {'missing_headers': [], 'found_headers': {}}
    
    try:
        response = requests.get(target, timeout=10)
        for header, message in security_headers.items():
            if header not in response.headers:
                results['missing_headers'].append({
                    'header': header,
                    'description': message
                })
            else:
                results['found_headers'][header] = response.headers[header]
    except Exception as e:
        logging.error(f"Error checking security headers: {str(e)}")
        results['error'] = str(e)
    
    return results

def check_cors_config(target):
    """Check for CORS misconfiguration."""
    results = {'misconfigured': False, 'headers': {}}
    
    try:
        # Make a request with a fake origin
        headers = {'Origin': 'https://evil.com'}
        response = requests.get(target, headers=headers, timeout=10)
        
        cors_headers = [
            'Access-Control-Allow-Origin',
            'Access-Control-Allow-Credentials',
            'Access-Control-Allow-Methods',
            'Access-Control-Allow-Headers',
            'Access-Control-Expose-Headers'
        ]
        
        for header in cors_headers:
            if header in response.headers:
                results['headers'][header] = response.headers[header]
        
        # Check for permissive CORS config
        if 'Access-Control-Allow-Origin' in response.headers:
            origin = response.headers['Access-Control-Allow-Origin']
            if origin == '*' or origin == 'https://evil.com':
                results['misconfigured'] = True
                results['risk'] = 'Permissive CORS policy could allow cross-origin attacks'
                
            if ('Access-Control-Allow-Credentials' in response.headers and
                response.headers['Access-Control-Allow-Credentials'].lower() == 'true' and
                origin != 'null'):
                results['misconfigured'] = True
                results['risk'] = 'CORS policy with credentials and non-null origin allows credential theft'
    except Exception as e:
        logging.error(f"Error checking CORS config: {str(e)}")
        results['error'] = str(e)
    
    return results

def fuzz_parameters(target, params=None):
    """Perform basic parameter fuzzing."""
    if not params:
        # If no parameters provided, try to extract them from URL
        parsed = urlparse(target)
        params = dict(parse_qsl(parsed.query))
    
    if not params:
        return {'error': 'No parameters to fuzz'}
    
    results = []
    
    # Payloads for basic tests
    payloads = {
        'xss': [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '\'><script>alert(1)</script>',
            '<img src=x onerror=alert(1)>'
        ],
        'sqli': [
            "'",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "'; DROP TABLE users; --"
        ],
        'command_injection': [
            '|ls',
            ';ls;',
            '`ls`',
            '$(ls)'
        ]
    }
    
    # Baseline request to compare against
    try:
        baseline_response = requests.get(target, timeout=10)
        baseline_length = len(baseline_response.text)
        baseline_status = baseline_response.status_code
    except Exception as e:
        logging.error(f"Error establishing baseline: {str(e)}")
        return {'error': str(e)}
    
    # Test each parameter with each payload
    for param in params:
        for vuln_type, payload_list in payloads.items():
            for payload in payload_list:
                try:
                    # Create a copy of the original parameters
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    # Rebuild URL with test parameters
                    parsed = urlparse(target)
                    new_query = urlencode(test_params)
                    new_url = parsed._replace(query=new_query).geturl()
                    
                    response = requests.get(new_url, timeout=10)
                    
                    # Check for anomalies
                    length_diff = abs(len(response.text) - baseline_length)
                    status_changed = response.status_code != baseline_status
                    reflected = payload in response.text
                    
                    if status_changed or length_diff > 50 or reflected:
                        results.append({
                            'param': param,
                            'payload': payload,
                            'type': vuln_type,
                            'url': new_url,
                            'status_code': response.status_code,
                            'length_diff': length_diff,
                            'reflected': reflected,
                            'potential_vulnerability': True
                        })
                except Exception as e:
                    logging.error(f"Error testing {param} with {payload}: {str(e)}")
    
    return results

def run_zap_scan(target, scan_type='quick'):
    """
    Run an OWASP ZAP scan against the target.
    This is a simplified implementation - in a real scenario you'd use the ZAP API.
    """
    # Check if ZAP is available
    try:
        # Try to execute ZAP command to check if it's available
        subprocess.run(['zap.sh', '-version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False)
    except Exception:
        logging.warning("OWASP ZAP not available or not in PATH")
        return {
            'error': 'OWASP ZAP not available',
            'message': 'This is a simplified implementation. In a real scenario, you would use the ZAP API.'
        }
    
    # For demo purposes, return simulated results
    # In a real implementation, you would:
    # 1. Start ZAP
    # 2. Access the ZAP API
    # 3. Run the appropriate scan
    # 4. Collect and process results
    
    # Simulated results
    result_types = [
        {'name': 'Cross Site Scripting (Reflected)', 'risk': 'High'},
        {'name': 'SQL Injection', 'risk': 'High'},
        {'name': 'Path Traversal', 'risk': 'Medium'},
        {'name': 'Remote OS Command Injection', 'risk': 'High'},
        {'name': 'Server Side Template Injection', 'risk': 'High'},
        {'name': 'Cross-Domain Misconfiguration', 'risk': 'Medium'},
        {'name': 'Cookie Without SameSite Attribute', 'risk': 'Low'},
        {'name': 'Missing Anti-CSRF Tokens', 'risk': 'Medium'},
        {'name': 'Content Security Policy (CSP) Header Not Set', 'risk': 'Medium'},
        {'name': 'X-Frame-Options Header Not Set', 'risk': 'Medium'}
    ]
    
    # For quick scan, return fewer results
    if scan_type == 'quick':
        result_types = result_types[:3]
    
    # Simulate random findings
    results = []
    for _ in range(random.randint(2, 5)):
        vuln = random.choice(result_types)
        results.append({
            'name': vuln['name'],
            'risk': vuln['risk'],
            'url': urljoin(target, random_path()),
            'parameter': random_parameter(),
            'description': f"This is a simulated {vuln['name']} finding."
        })
    
    return {
        'scan_type': scan_type,
        'target': target,
        'findings': results,
        'message': 'This is a simulated ZAP scan result for demonstration purposes.'
    }

def random_path():
    """Generate a random path for demo purposes."""
    paths = [
        '/login',
        '/admin',
        '/search',
        '/product',
        '/user',
        '/profile',
        '/settings',
        '/cart',
        '/checkout'
    ]
    return random.choice(paths)

def random_parameter():
    """Generate a random parameter name for demo purposes."""
    params = [
        'id',
        'user_id',
        'product_id',
        'query',
        'name',
        'email',
        'password',
        'token',
        'sort'
    ]
    return random.choice(params)

def perform_vulnerability_scan(target, scan_type='quick', zap_enabled=False, fuzzing_enabled=False):
    """
    Main vulnerability scanning function.
    """
    if not target:
        return {'error': 'No target specified'}
    
    # Ensure target has scheme
    if not target.startswith(('http://', 'https://')):
        target = 'http://' + target
    
    logging.info(f"Starting vulnerability scan for {target}")
    
    results = {
        'target': target,
        'scan_type': scan_type,
        'timestamp': datetime.datetime.now().isoformat(),
        'security_headers': {},
        'status_codes': [],
        'cors_config': {},
        'fuzzing_results': [],
        'zap_scan': {}
    }
    
    # Check security headers
    results['security_headers'] = check_security_headers(target)
    
    # Check status codes
    results['status_codes'] = check_status_codes(target)
    
    # Check CORS configuration
    results['cors_config'] = check_cors_config(target)
    
    # Fuzzing test if enabled
    if fuzzing_enabled:
        # Extract parameters from URL
        parsed = urlparse(target)
        params = dict(parse_qsl(parsed.query))
        
        if params:
            results['fuzzing_results'] = fuzz_parameters(target, params)
        else:
            results['fuzzing_results'] = {'message': 'No parameters found for fuzzing'}
    
    # Run ZAP scan if enabled
    if zap_enabled:
        results['zap_scan'] = run_zap_scan(target, scan_type)
    
    return results
